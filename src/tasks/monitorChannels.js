// src/tasks/monitorChannels.js
const logger = require('../utils/logger');
const supabase = require('../config/supabase');

/**
 * Fun√ß√£o principal que monitora os canais do YouTube
 * Usa projetos que j√° foram validados pelo activeProjects
 */
async function monitorChannels() {
    try {
        logger.info('\nüöÄ Iniciando monitoramento de canais do YouTube...');
        
        // 1. Busca diretamente os projetos QUE J√Å EST√ÉO VALIDADOS no sistema
        const { data: projetosValidos, error } = await supabase
            .from('Projeto')
            .select(`
                id,
                "Project name",
                "Youtube Active",
                integracao_valida
            `)
            .eq('Youtube Active', true)
            .eq('integracao_valida', true);
        
        if (error) {
            logger.error('‚ùå Erro ao buscar projetos v√°lidos:', error);
            return false;
        }
        
        if (!projetosValidos?.length) {
            logger.warn('‚ö†Ô∏è Nenhum projeto com integra√ß√£o YouTube v√°lida encontrado');
            logger.info('‚ÑπÔ∏è Dica: Execute primeiro "node src/tasks/activeProjects.js" para validar as integra√ß√µes');
            return false;
        }
        
        logger.info(`üìä Encontrados ${projetosValidos.length} projetos com integra√ß√£o v√°lida:`);
        projetosValidos.forEach(p => logger.info(`   ‚Üí ${p['Project name']} (ID: ${p.id})`));
        
        // 2. Garante que a tabela de canais existe
        await garantirTabelaCanais();
        
        // 3. Para cada projeto V√ÅLIDO
        for (const projeto of projetosValidos) {
            try {
                logger.info(`\nüìä Processando canais do projeto: ${projeto['Project name']} (ID: ${projeto.id})`);
                
                // Busca o ranking atual de canais da view especificada
                const { data: rankingCanais, error: rankError } = await supabase
                    .from('channel_lead_ranking')
                    .select(`
                        author_channel_id,
                        author_name,
                        total_comments,
                        lead_comments,
                        avg_lead_score,
                        last_lead_interaction,
                        video_count,
                        ranking_position
                    `)
                    .eq('projeto_id', projeto.id)
                    .order('ranking_position', { ascending: true })
                    .limit(30);
                
                if (rankError) {
                    logger.error(`‚ùå Erro ao buscar ranking para projeto ${projeto.id}:`, rankError);
                    continue;
                }
                
                if (!rankingCanais?.length) {
                    logger.warn(`‚ö†Ô∏è Nenhum canal ranqueado para projeto ${projeto.id}`);
                    
                    // Verifica se existem leads para este projeto
                    const { count, error: countError } = await supabase
                        .from('Comentarios_Principais')
                        .select('*', { count: 'exact', head: true })
                        .eq('led', true)
                        .eq('projeto_id', projeto.id);
                    
                    if (countError) {
                        logger.error(`‚ùå Erro ao verificar leads: ${countError.message}`);
                    } else if (count === 0) {
                        logger.info(`‚ÑπÔ∏è Projeto ${projeto.id} n√£o possui leads identificados`);
                    } else {
                        logger.info(`‚ÑπÔ∏è Projeto ${projeto.id} tem ${count} leads, mas nenhum canal ranqueado`);
                    }
                    
                    continue;
                }
                
                logger.info(`‚ÑπÔ∏è Encontrados ${rankingCanais.length} canais ranqueados para monitorar`);
                
                // Atualiza os canais usando a fun√ß√£o interna
                const updated = await updateTopChannels(projeto.id, rankingCanais);
                
                if (updated) {
                    logger.success(`‚úÖ Canais atualizados com sucesso para projeto ${projeto.id}`);
                } else {
                    logger.warn(`‚ö†Ô∏è Atualiza√ß√£o de canais incompleta para projeto ${projeto.id}`);
                }
            } catch (projetoError) {
                logger.error(`‚ùå Erro ao processar projeto ${projeto.id}:`, projetoError);
            }
        }
        
        logger.success('\n‚úÖ Monitoramento de canais finalizado com sucesso');
        return true;
    } catch (error) {
        logger.error('‚ùå Erro no monitoramento de canais:', error);
        return false;
    }
}

/**
 * Atualiza os 30 principais canais de um projeto baseado no ranking
 */
async function updateTopChannels(projectId, channels) {
    try {
        logger.info(`Atualizando top canais para projeto ${projectId}...`);

        if (!channels || channels.length === 0) {
            logger.warn('‚ö†Ô∏è Nenhum canal para atualizar');
            return false;
        }

        // Prepara os canais para inser√ß√£o/atualiza√ß√£o
        const channelsToUpdate = channels.map(channel => ({
            "Nome": channel.author_name || 'Canal sem nome',
            "channel_id": channel.author_channel_id, // Usa exatamente o ID da view
            "Projeto": projectId,
            "ranking_score": channel.avg_lead_score || 0,
            "rank_position": channel.ranking_position || 0,
            "total_leads": channel.lead_comments || 0,
            "total_comments": channel.total_comments || 0,
            "last_interaction": channel.last_lead_interaction,
            "videos": channel.video_count || 0,
            "Criador": channel.author_name || 'Canal sem nome',
            "ultima_atualizacao": new Date().toISOString()
        }));

        let atualizados = 0;
        let novos = 0;
        let erros = 0;

        // Processa cada canal
        for (const channel of channelsToUpdate) {
            // Verifica se tem ID de canal
            if (!channel.channel_id) {
                logger.warn(`‚ö†Ô∏è Canal sem ID v√°lido: ${channel.Nome}`);
                erros++;
                continue;
            }

            try {
                // Verifica se canal j√° existe
                const { data: existing, error: searchError } = await supabase
                    .from('Canais do youtube')
                    .select('id')
                    .eq('channel_id', channel.channel_id)
                    .eq('Projeto', projectId)
                    .maybeSingle();

                if (searchError) {
                    logger.error(`‚ùå Erro ao buscar canal ${channel.channel_id}: ${searchError.message}`);
                    erros++;
                    continue;
                }

                if (existing?.id) {
                    // Atualiza canal existente
                    const { error: updateError } = await supabase
                        .from('Canais do youtube')
                        .update(channel)
                        .eq('id', existing.id);

                    if (updateError) {
                        logger.error(`‚ùå Erro ao atualizar canal ${channel.channel_id}: ${updateError.message}`);
                        erros++;
                    } else {
                        atualizados++;
                    }
                } else {
                    // Insere novo canal
                    const { error: insertError } = await supabase
                        .from('Canais do youtube')
                        .insert([channel]);

                    if (insertError) {
                        logger.error(`‚ùå Erro ao inserir canal ${channel.channel_id}: ${insertError.message}`);
                        erros++;
                    } else {
                        novos++;
                    }
                }
            } catch (canalError) {
                logger.error(`‚ùå Erro ao processar canal ${channel.channel_id}: ${canalError.message}`);
                erros++;
            }
        }

        logger.info(`üìä Resumo: ${atualizados} canais atualizados, ${novos} novos canais, ${erros} erros`);
        return (atualizados + novos) > 0; // Sucesso se pelo menos um canal foi processado
    } catch (error) {
        logger.error('‚ùå Erro em updateTopChannels:', error.message);
        return false;
    }
}

/**
 * Garante que a tabela de canais do YouTube existe
 */
async function garantirTabelaCanais() {
    try {
        // Testa se a tabela existe
        const { error } = await supabase
            .from('Canais do youtube')
            .select('id')
            .limit(1);
            
        if (error) {
            logger.warn('‚ö†Ô∏è Tabela "Canais do youtube" parece n√£o existir, tentando criar...');
            
            // Tenta criar a tabela
            const createSQL = `
              CREATE TABLE IF NOT EXISTS "Canais do youtube" (
                id BIGSERIAL PRIMARY KEY,
                "Nome" TEXT,
                channel_id TEXT NOT NULL,
                "Projeto" BIGINT,
                ranking_score FLOAT,
                rank_position INTEGER,
                total_leads INTEGER,
                total_comments INTEGER,
                last_interaction TIMESTAMP WITH TIME ZONE,
                videos INTEGER,
                "Criador" TEXT,
                ultima_atualizacao TIMESTAMP WITH TIME ZONE DEFAULT now()
              );
              
              -- Adiciona √≠ndice √∫nico se n√£o existir
              CREATE UNIQUE INDEX IF NOT EXISTS canais_youtube_channel_projeto_idx 
              ON "Canais do youtube" (channel_id, "Projeto");
            `;
            
            // Tenta executar o SQL via supabase
            try {
                // Se o supabase tiver fun√ß√£o para executar SQL diretamente
                const { error: sqlError } = await supabase.rpc('execute_sql', { sql: createSQL });
                
                if (sqlError) {
                    logger.error(`‚ùå Erro ao criar tabela: ${sqlError.message}`);
                    logger.info('‚ÑπÔ∏è A tabela pode precisar ser criada manualmente');
                } else {
                    logger.success('‚úÖ Tabela de canais criada com sucesso');
                }
            } catch (rpcError) {
                logger.error(`‚ùå Erro ao executar SQL: ${rpcError.message}`);
                logger.info('‚ÑπÔ∏è A fun√ß√£o RPC pode n√£o existir ou voc√™ n√£o tem permiss√µes');
            }
        } else {
            logger.info('‚úÖ Tabela "Canais do youtube" j√° existe');
        }
    } catch (error) {
        logger.error('‚ùå Erro ao verificar tabela de canais:', error.message);
    }
}

// Se executado diretamente
if (require.main === module) {
    (async () => {
        await monitorChannels();
    })();
}

module.exports = { monitorChannels };